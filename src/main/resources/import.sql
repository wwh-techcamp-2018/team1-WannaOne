INSERT INTO user(id, email, password, name) VALUES (1, 'doy@woowahan.com', '$2a$10$b/fsUrWITZQ1CpB.VhaVvOmUo8fqbKoZPy4f/RwarSaBfN0.0Jk7e', 'doy');
INSERT INTO user(id, email, password, name) VALUES (2, 'dain@woowahan.com', '$2a$10$b/fsUrWITZQ1CpB.VhaVvOmUo8fqbKoZPy4f/RwarSaBfN0.0Jk7e', 'dain');
INSERT INTO note_book(id, title, owner_id) values (1, 'tech', 1);
INSERT INTO note_book(id, title, owner_id) values (2, '단위 테스트, TDD', 1);
INSERT INTO note_book(id, title, owner_id) values (3, '자바 웹 프로그래밍', 1);
INSERT INTO note_book(id, title, owner_id) values (4, 'ATDD 기반 웹 프로그래밍', 1);
INSERT INTO note_book(id, title, owner_id) values (5, 'HTML,CSS, JS 기초', 2);
INSERT INTO note_book(id, title, owner_id) values (6, '배민찬 서비스 개발', 2);
INSERT INTO note_book(id, title, owner_id) values (7, '우아한 프로젝트', 2);
INSERT INTO note(id, title, text, register_datetime, update_datetime, note_book_id, deleted, writer_id) values (1, '01.Swagger 적용하기', '<h2><div>Swagger 적용하기<br></div></h2><div>이거 적용하는데 13초 정도 걸린거 같음.<br></div><div><br></div><div>아래 의존성 추가.<br></div><pre data-language="yaml" class="lang-yaml" data-te-codeblock=""><div>compile group: ''io.springfox'', name: ''springfox-swagger2'', version: ''2.5.0''</div><div>compile group: ''io.springfox'', name: ''springfox-swagger-ui'', version: ''2.5.0''</div></pre><div>아래의 설정파일 추가.<br></div><pre data-language="java" class="lang-java" data-te-codeblock=""><div>package codesquad.config;</div><div><br></div><div>import org.springframework.context.annotation.Bean;</div><div>import org.springframework.context.annotation.Configuration;</div><div>import springfox.documentation.builders.PathSelectors;</div><div>import springfox.documentation.builders.RequestHandlerSelectors;</div><div>import springfox.documentation.spi.DocumentationType;</div><div>import springfox.documentation.spring.web.plugins.Docket;</div><div>import springfox.documentation.swagger2.annotations.EnableSwagger2;</div><div><br></div><div>@Configuration</div><div>@EnableSwagger2</div><div>public class SwaggerConfig {</div><div><br></div><div>    @Bean</div><div>    public Docket api() {</div><div>        return new Docket(DocumentationType.SWAGGER_2)</div><div>                .select()</div><div>                .apis(RequestHandlerSelectors.any())// 모든 RequestMapping 추출</div><div>                .paths(PathSelectors.ant("/api/**")) // 그중에 /api/** 인 URL 필터</div><div>                .build();</div><div>    }</div><div>}</div></pre><div>이제 실행 후에 localhost:8080/swagger-ui.html 로 접속해보자. 끝<br></div>','2018-08-14 13:00:00', '2018-08-14 13:54:00', 1, false, 1);
INSERT INTO note(id, title, text, register_datetime, update_datetime, note_book_id, deleted, writer_id) values (2, '02.Java 8 Stream API', '<h2><div>Java 8 Stream API<br></div></h2><h3><div>스트림이란?<br></div></h3><ul><li>데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소이다.<br></li><li>다양한 데이터 소스를 표준화된 방법으로 다루기 위한 라이브러리이다.<br></li><li>데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다.<br></li><li>데이터소스를 추상화하였다는 것은, 데이터 소스가 무엇이든 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.<br></li></ul><h3><div>스트림의 특징<br></div></h3><ol><li>스트림은 데이터 소스를 변경하지 않는다.<br></li><ul><li><div>스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다.<br></div><div> 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수 있다.<br></div></li></ul><li>스트림은 일회용이다.<br></li><ul><li>스트림 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.<br></li></ul><li>스트림은 작업 내부를 반복적으로 처리한다.<br></li><ul><li><div>스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 ''내부 반복''이다.<br></div><div> 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.<br></div></li></ul><li>지연된 연산<br></li><ul><li><div>스트림 연산에서는 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다.<br></div><div> 스트림에 대해 <code data-backticks="1">sort()</code>나 <code data-backticks="1">distinct()</code>같은 중간 연산을 호출해도 즉각적으로 수행되지 않는다는 것이다.<br></div><div> 중간연산을 호출하는 것은 단지 어떤 작업이 수행되어야하는지를 지정해주는 것일 뿐이다.<br></div><div> 최종연산이 수행되어서야 스트림의 요소들이 중간연산을 거치고 최종연산에 소모된다.<br></div></li></ul><li>기본형 스트림<br></li><ul><li><div>오토박싱, 언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 <code data-backticks="1">IntStream</code>, <code data-backticks="1">LongStream</code>, <code data-backticks="1">DoubleStream</code> 이 제공된다.<br></div><div> 일반적으로 <code data-backticks="1">Stream&lt; Integer&gt;</code> 대신 <code data-backticks="1">IntStream</code>을 사용하는 것이 더 효율적이고, <code data-backticks="1">IntStream</code>에는 <code data-backticks="1">int</code>타입으로 작업하는데 유용한 메서드들이 포함되어있다.<br></div></li></ul><li>병렬 스트림<br></li><ul><li><div>스트림은 내부적으로 fork&amp;join framework를 이용해서 연산을 자동적으로 병렬로 수행한다.<br></div><div> <code data-backticks="1">parallel()</code> 메서드를 호출하면 병렬로 연산이 수행되고, <code data-backticks="1">sequential()</code> 메서드를 호출하면 병렬로 처리되지 않게 된다.<br></div><div> 모든 스트림은 기본적으로 병렬 스트림이 아니기 때문에 <code data-backticks="1">sequential()</code> 메서드는 <code data-backticks="1">parallel()</code>를 취소할 때만 사용한다.<br></div></li></ul></ol><h3><div>스트림의 사용법<br></div></h3><div><code data-backticks="1">orders.스트림 생성().중간 연산().최종 연산()</code><br></div><ol><li>스트림을 생성한다.<br></li><li>초기 스트림을 다른 스트림으로 변환하는 중간 연산(intermediate operation)들을 하<s>&#8203;</s>나 이상의 단계로 지정한다.<br></li><li><div>결과를 산출하기 위해 최종 연산(terminal operation)을 적용한다.<br></div><div> 이 연산은 앞선 지연 연산(lazy operation)들의 실행을 강제한다.<br></div><div> 이후로는 해당 스트림을 더는 사용할 수 없다.<br></div></li></ol><h3><div>스트림의 주요 연산<br></div></h3><ul><li>중간 연산<br></li></ul><table><thead><tr><th align="left">중간 연산</th><th align="left">설명</th></tr></thead><tbody><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; distinct()</code></td><td align="left">중복 제거</td></tr><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; filter(Predicate &lt; T &gt; predicate)</code></td><td align="left">조건에 안 맞는 요소 제외</td></tr><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; limit(long maxSize)</code></td><td align="left">스트림의 일부 잘라내기</td></tr><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; skip(ling n)</code></td><td align="left">스트림의 일부 건너뛰기</td></tr><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; peek(Consumer&lt; T &gt; action)</code></td><td align="left">스트림의 요소에 작업수행</td></tr><tr><td align="left"><code data-backticks="1">Stream &lt; T &gt; sorted()</code></td><td align="left">스트림의 요소 정렬</td></tr></tbody></table><ul><li>최종 연산<br></li></ul><table><thead><tr><th align="left">최종 연산</th><th align="left">설명</th></tr></thead><tbody><tr><td align="left"><code data-backticks="1">void forEach(Consumer &lt;? super T&gt; action)</code></td><td align="left">각 요소에 지정된 작업 수행</td></tr><tr><td align="left"><code data-backticks="1">long count()</code></td><td align="left">스트림의 요소 개수</td></tr><tr><td align="left"><code data-backticks="1">Optional &lt; T &gt; max (Comparator &lt;? super T&gt; comparator)</code></td><td align="left">스트림의 최댓값</td></tr><tr><td align="left"><code data-backticks="1">Optional &lt; T &gt; min (Comparator &lt;? super T&gt; comparator)</code></td><td align="left">스트림의 최솟값</td></tr><tr><td align="left"><code data-backticks="1">Optional &lt; T &gt; findAny()</code></td><td align="left">아무거나 하나</td></tr><tr><td align="left"><code data-backticks="1">Optional &lt; T &gt; findFirst()</code></td><td align="left">스트림의 첫번째 요소</td></tr><tr><td align="left"><code data-backticks="1">Optional &lt; T &gt; reduce (BinaryOperator &lt; T &gt; accumulator)</code></td><td align="left">스트림의 요소를 하나씩 줄여가면서 계산하고 최종결과를 반환</td></tr><tr><td align="left"><code data-backticks="1">boolean allMatch(Pradicate &lt; T &gt; p)</code></td><td align="left">모두 만족하는지?</td></tr><tr><td align="left"><code data-backticks="1">boolean anyMatch(Pradicate &lt; T &gt; p)</code></td><td align="left">하나라도 만족하는지?</td></tr><tr><td align="left"><code data-backticks="1">boolean noneMatch(Pradicate &lt; T &gt; p)</code></td><td align="left">모두 만족하지 않는지?</td></tr><tr><td align="left"><code data-backticks="1">Object[] toArray()</code></td><td align="left">스트림의 모든 요소를 배열로 반환</td></tr></tbody></table><div><br></div>','2018-08-14 13:00:00', '2018-08-14 13:55:00', 1, false, 1);
INSERT INTO note(id, title, text, register_datetime, update_datetime, note_book_id, deleted, writer_id) values (3, '03.JPA Auditing을 이용해 생성일자 자동 생성', '<h2><div>JPA Auditing 활용<br></div></h2><div>audit는 감시하다..이런 뜻이라고 하는데 여튼<br></div><div><br></div><div>실무에서 테이블을 생성할 때 항상 그 데이터가 생성된 시점, 어떤 회원이 생성했는지에 대해서는 항상 기록을 남겼었음<br></div><div><br></div><div>생성된 시점, 어떤 회원이 생성했는지, 업데이트된 시점과 업데이트된 회원에 대해서 기록을 남기는데 모든 테이블에 거의 다 적용되므로 JPA에서 Entity의 변수로 <code data-backticks="1">createBy, createdDate, lastModifiedBy, lastModifiedDate</code> 를 작성한다면 중복이 많이 생김<br></div><div><br></div><div>아래와 같은 기능을 활용하면 중복을 제거하면서 테이블에 대한 기록을 남길 수 있다.<br></div><div><br></div><div><code data-backticks="1">JPA Auditing</code> 은 간단하게 말하면 생성일자, 생성자, 업데이트 일자, 업데이트 한 사람에 대한 기록을 자동으로 남겨주는 것.<br></div><pre data-language="java" class="lang-java" data-te-codeblock=""><div>package com.tram.springbootangularboard.domain;</div><div><br></div><div>import lombok.Getter;</div><div>import org.springframework.data.annotation.CreatedBy;</div><div>import org.springframework.data.annotation.CreatedDate;</div><div>import org.springframework.data.annotation.LastModifiedBy;</div><div>import org.springframework.data.annotation.LastModifiedDate;</div><div>import org.springframework.data.jpa.domain.support.AuditingEntityListener;</div><div><br></div><div>import javax.persistence.Column;</div><div>import javax.persistence.EntityListeners;</div><div>import javax.persistence.ManyToOne;</div><div>import javax.persistence.MappedSuperclass;</div><div>import java.time.LocalDateTime;</div><div><br></div><div>@MappedSuperclass</div><div>@EntityListeners(value = { AuditingEntityListener.class })</div><div>@Getter</div><div>public abstract class AuditorEntity {</div><div>    @Column(nullable = false, updatable = false)</div><div>    @CreatedDate</div><div>    private LocalDateTime createdDate;</div><div>    @LastModifiedDate</div><div>    private LocalDateTime lastModifiedDate;</div><div>    @ManyToOne</div><div>    @CreatedBy</div><div>    private Account createdBy;</div><div>    @ManyToOne @LastModifiedBy</div><div>    private Account lastModifiedBy;</div><div>}</div></pre><div>이제 위와같은 BaseEntity를 상속해서 아래처럼 생성해주면 위의 데이터들을 <code data-backticks="1">Repository</code> 에서 save할때 자동으로 넣어주게 된다.<br></div><pre data-language="java" class="lang-java" data-te-codeblock=""><div>public class Account extends AuditorEntity {</div><div><br></div><div>    @Id</div><div>    @GeneratedValue(strategy = GenerationType.AUTO)</div><div>    private Long id;</div><div>    //...</div><div>}</div></pre><div>위처럼 상속해서 사용하면 되고 <code data-backticks="1">Jpa Auditing</code> 에 대한 <code data-backticks="1">Configuration</code>만 추가적으로 더 넣어주면 된다.<br></div><pre data-language="java" class="lang-java" data-te-codeblock=""><div>@EnableJpaAuditing(auditorAwareRef = "securityAuditorAware")</div><div>@Configuration</div><div>public class JpaAuditingConfig {</div><div><br></div><div>}</div></pre><div>위에서 auditorAwareRef는 누구에 의해서 작성, 수정되었는지를 가져오기 위해서 현재 로그인 된 사용자의 정보를 내려주기 위해서 추가한 부분이다.<br></div><pre data-language="java" class="lang-java" data-te-codeblock=""><div>@Component</div><div>public class SecurityAuditorAware implements AuditorAware&lt;Account&gt; {</div><div>    @Autowired</div><div>    private AccountService accountService;</div><div>    @Override</div><div>    public Optional&lt;Account&gt; getCurrentAuditor() {</div><div>        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</div><div>        if(authentication instanceof AnonymousAuthenticationToken) {</div><div>            return Optional.empty();</div><div>        }</div><div>        PostAuthorizationToken postAuthorizationToken = (PostAuthorizationToken)authentication;</div><div>        return Optional.ofNullable(accountService.findByEmail(postAuthorizationToken.getAccountContext().getAccount().getEmail()));</div><div>    }</div><div>}</div></pre><div>위와 같은 구조인데 스프링 시큐리티가 적용되어 있으므로 코드에 대해서는 신경쓰지 말고 그냥 로그인 유저의 정보를 받아오기 위한거라고 생각해주면 된다. 우리가 구현한 서비스에 맞춘다면 <code data-backticks="1">@LoginUser</code>나 <code data-backticks="1">HttpSession.getAttribute("user")</code> 이런 걸 반환해주면 된다. 그러면 자동으로 <code data-backticks="1">createdBy</code> 에 현재 로그인 된 사용자 정보가 들어가게 된다.(이건 안된대 ThreadLocal에 저장되도록 변경한 다음에 TreadLocal을 이용해 가져와야 한다고 함.)<br></div><div><br></div><div>내가 그냥 메모용으로 쓴 거니까 내용은 아래를 참고하는게 좋을 듯<br></div><div><br></div><div>참고<br></div><h3><div>@MappedSuperclass<br></div></h3><div>부모 클래스와 자식 클래스 모두 데이타베이스 테이블과 매핑을 하는데, 상속받는 자식클래스에게 매핑 정보만 제공하고 싶을때 이 어노테이션을 사용한다.<br></div><div><br></div><div><a href="http://feco.tistory.com/13">MappedSuperclass</a><br></div><div><br></div><div><a href="http://blusky10.tistory.com/316">Jpa Auditing</a><br></div>', '2018-08-14 13:00:00', '2018-08-14 13:56:00', 1, false, 1);
INSERT INTO note(id, title, text, register_datetime, update_datetime, note_book_id, deleted, writer_id) values (4, 'TDD...', '<h3><div>TDD 최고!!!<div><h3>', '2018-08-14 13:00:00', '2018-08-14 13:57:00', 2, false, 1);
INSERT INTO comment(id, content, register_datetime, update_datetime, note_id, writer_id) values(1, '첫 댓글', '2018-08-14 13:00:00', '2018-08-14 13:54:00', 1, 2);
INSERT INTO comment(id, content, register_datetime, update_datetime, note_id, writer_id) values(2, '아이디어가 떨어지네요...', '2018-08-14 13:00:00', '2018-08-14 13:54:00', 1, 1);
INSERT INTO comment(id, content, register_datetime, update_datetime, note_id, writer_id) values(3, '우아노트 화이팅!!!', '2018-08-14 13:00:00', '2018-08-14 13:54:00', 1, 2);
INSERT INTO comment(id, content, register_datetime, update_datetime, note_id, writer_id) values(4, '두번째 글의 첫 댓글', '2018-08-14 13:00:00', '2018-08-14 13:54:00', 2, 1);
